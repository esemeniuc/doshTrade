schema {
  query: QueryRoot
  mutation: MutationRoot
  subscription: Subscription
}

# Directs the executor to query only when the field exists.
directive @ifdef on FIELD

type MutationRoot {
  # Returns a list of successfully added tickers.
  # Invalid (not found) tickers will not be returned.
  notificationRequest(
    tickerSymbols: [String!]!
    pushSubscription: PushSubscription!
  ): [String!]!
}

type OptionQuote {
  stringId: String!
  optionType: OptionType!
  strike: Float
  expiration: String!
  daysToExpiration: Int!
  bid: Float
  ask: Float
  last: Float
  delta: Float
  gamma: Float
  theta: Float
  vega: Float!
  rho: Float
  volatility: Float
  timeValue: Float!
}

type OptionRiskSummary {
  maxRisk: String!
  maxProfit: String!
  breakevenAtExpiration: String!
}

enum OptionStrategy {
  BUY_CALL
  BUY_PUT
  SELL_CALL
  SELL_PUT
}

enum OptionType {
  CALL
  PUT
}

input PushSubscription {
  endpoint: String!
  expirationTime: String
  keys: PushSubscriptionKeys!
}

input PushSubscriptionKeys {
  p256dh: String!
  auth: String!
}

type QueryRoot {
  # sends demo notification to client browser to verify notifications work as intended
  sendDemoNotification(pushSubscription: PushSubscription!): Boolean!
  getCurrentPrice(ticker: String!): String!
  getAvailableExpirations(ticker: String!): [String!]!

  # sends option chain for selected ticker
  # assumes expiration is UTC time
  getOptionChain(
    ticker: String!
    expiration: String!
    strategy: OptionStrategy!
  ): [OptionQuote!]!

  # sends computed risk values for a give option
  getRiskSummary(optionId: ID!, strategy: OptionStrategy!): OptionRiskSummary!
}

# Represents a stock's status
type Stock {
  ticker: String!
  price: String!
  rsi: Float!

  # % Change from the start of day
  percentChange: Float!
  timestamp: String!
}

type Subscription {
  yoloHandCuratedStocks(tickerSymbols: [String!]!): [Stock!]!
}
